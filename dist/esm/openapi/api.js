/* tslint:disable */
/* eslint-disable */
/**
 * Cosmos SDK - Legacy REST and gRPC Gateway docs
 * A REST interface for state queries, legacy transactions
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from './base';
export const CosmosGovV1beta1ProposalStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
};
/**
 * ProposalStatus enumerates the valid statuses of a proposal.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
 * @export
 * @enum {string}
 */
export const CosmosGovV1beta1ProposalStatus = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
};
export const CosmosGovV1beta1VoteOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
};
/**
 * VoteOption enumerates the valid vote options for a given governance proposal.   - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
 * @export
 * @enum {string}
 */
export const CosmosGovV1beta1VoteOption = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
};
export const CosmosGovV1beta1WeightedVoteOptionOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
};
/**
 * BondStatus is the status of a validator.   - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
 * @export
 * @enum {string}
 */
export const CosmosStakingV1beta1BondStatus = {
    Unspecified: 'BOND_STATUS_UNSPECIFIED',
    Unbonded: 'BOND_STATUS_UNBONDED',
    Unbonding: 'BOND_STATUS_UNBONDING',
    Bonded: 'BOND_STATUS_BONDED'
};
export const CosmosStakingV1beta1ValidatorStatusEnum = {
    Unspecified: 'BOND_STATUS_UNSPECIFIED',
    Unbonded: 'BOND_STATUS_UNBONDED',
    Unbonding: 'BOND_STATUS_UNBONDING',
    Bonded: 'BOND_STATUS_BONDED'
};
/**
 * SignMode represents a signing mode with its own security guarantees.   - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be rejected  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is verified with raw bytes from Tx  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some human-readable textual representation on top of the binary representation from SIGN_MODE_DIRECT  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses Amino JSON and will be removed in the future
 * @export
 * @enum {string}
 */
export const CosmosTxSigningV1beta1SignMode = {
    Unspecified: 'SIGN_MODE_UNSPECIFIED',
    Direct: 'SIGN_MODE_DIRECT',
    Textual: 'SIGN_MODE_TEXTUAL',
    LegacyAminoJson: 'SIGN_MODE_LEGACY_AMINO_JSON'
};
/**
 * BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.   - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering  - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for the tx to be committed in a block.  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for a CheckTx execution response only.  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns immediately.
 * @export
 * @enum {string}
 */
export const CosmosTxV1beta1BroadcastMode = {
    Unspecified: 'BROADCAST_MODE_UNSPECIFIED',
    Block: 'BROADCAST_MODE_BLOCK',
    Sync: 'BROADCAST_MODE_SYNC',
    Async: 'BROADCAST_MODE_ASYNC'
};
export const CosmosTxV1beta1BroadcastTxRequestModeEnum = {
    Unspecified: 'BROADCAST_MODE_UNSPECIFIED',
    Block: 'BROADCAST_MODE_BLOCK',
    Sync: 'BROADCAST_MODE_SYNC',
    Async: 'BROADCAST_MODE_ASYNC'
};
export const CosmosTxV1beta1ModeInfoSingleModeEnum = {
    Unspecified: 'SIGN_MODE_UNSPECIFIED',
    Direct: 'SIGN_MODE_DIRECT',
    Textual: 'SIGN_MODE_TEXTUAL',
    LegacyAminoJson: 'SIGN_MODE_LEGACY_AMINO_JSON'
};
/**
 * - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
 * @export
 * @enum {string}
 */
export const CosmosTxV1beta1OrderBy = {
    Unspecified: 'ORDER_BY_UNSPECIFIED',
    Asc: 'ORDER_BY_ASC',
    Desc: 'ORDER_BY_DESC'
};
export const InlineObject16ModeEnum = {
    Unspecified: 'BROADCAST_MODE_UNSPECIFIED',
    Block: 'BROADCAST_MODE_BLOCK',
    Sync: 'BROADCAST_MODE_SYNC',
    Async: 'BROADCAST_MODE_ASYNC'
};
export const InlineResponse20035BlockEvidenceDuplicateVoteEvidenceVoteATypeEnum = {
    Unknown: 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote: 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit: 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal: 'SIGNED_MSG_TYPE_PROPOSAL'
};
export const InlineResponse20035BlockEvidenceLightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesBlockIdFlagEnum = {
    Unknown: 'BLOCK_ID_FLAG_UNKNOWN',
    Absent: 'BLOCK_ID_FLAG_ABSENT',
    Commit: 'BLOCK_ID_FLAG_COMMIT',
    Nil: 'BLOCK_ID_FLAG_NIL'
};
export const InlineResponse20052ProposalsStatusEnum = {
    Unspecified: 'PROPOSAL_STATUS_UNSPECIFIED',
    DepositPeriod: 'PROPOSAL_STATUS_DEPOSIT_PERIOD',
    VotingPeriod: 'PROPOSAL_STATUS_VOTING_PERIOD',
    Passed: 'PROPOSAL_STATUS_PASSED',
    Rejected: 'PROPOSAL_STATUS_REJECTED',
    Failed: 'PROPOSAL_STATUS_FAILED'
};
export const InlineResponse20057OptionsOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
};
export const InlineResponse20057VotesOptionEnum = {
    Unspecified: 'VOTE_OPTION_UNSPECIFIED',
    Yes: 'VOTE_OPTION_YES',
    Abstain: 'VOTE_OPTION_ABSTAIN',
    No: 'VOTE_OPTION_NO',
    NoWithVeto: 'VOTE_OPTION_NO_WITH_VETO'
};
export const InlineResponse20066ValidatorsStatusEnum = {
    Unspecified: 'BOND_STATUS_UNSPECIFIED',
    Unbonded: 'BOND_STATUS_UNBONDED',
    Unbonding: 'BOND_STATUS_UNBONDING',
    Bonded: 'BOND_STATUS_BONDED'
};
export const SingleRepresentsASingleSignerModeEnum = {
    Unspecified: 'SIGN_MODE_UNSPECIFIED',
    Direct: 'SIGN_MODE_DIRECT',
    Textual: 'SIGN_MODE_TEXTUAL',
    LegacyAminoJson: 'SIGN_MODE_LEGACY_AMINO_JSON'
};
/**
 *
 * @export
 * @enum {string}
 */
export const TendermintTypesBlockIDFlag = {
    Unknown: 'BLOCK_ID_FLAG_UNKNOWN',
    Absent: 'BLOCK_ID_FLAG_ABSENT',
    Commit: 'BLOCK_ID_FLAG_COMMIT',
    Nil: 'BLOCK_ID_FLAG_NIL'
};
export const TendermintTypesCommitSigBlockIdFlagEnum = {
    Unknown: 'BLOCK_ID_FLAG_UNKNOWN',
    Absent: 'BLOCK_ID_FLAG_ABSENT',
    Commit: 'BLOCK_ID_FLAG_COMMIT',
    Nil: 'BLOCK_ID_FLAG_NIL'
};
/**
 * SignedMsgType is a type of signed message in the consensus.   - SIGNED_MSG_TYPE_PREVOTE: Votes  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
 * @export
 * @enum {string}
 */
export const TendermintTypesSignedMsgType = {
    Unknown: 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote: 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit: 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal: 'SIGNED_MSG_TYPE_PROPOSAL'
};
export const TendermintTypesVoteTypeEnum = {
    Unknown: 'SIGNED_MSG_TYPE_UNKNOWN',
    Prevote: 'SIGNED_MSG_TYPE_PREVOTE',
    Precommit: 'SIGNED_MSG_TYPE_PRECOMMIT',
    Proposal: 'SIGNED_MSG_TYPE_PROPOSAL'
};
/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authAccountsAddressGet: async (address, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('authAccountsAddressGet', 'address', address);
            const localVarPath = `/auth/accounts/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authAccountsAddressGet(address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authAccountsAddressGet(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AuthApiFp(configuration);
    return {
        /**
         *
         * @summary Get the account information on blockchain
         * @param {string} address Account address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authAccountsAddressGet(address, options) {
            return localVarFp.authAccountsAddressGet(address, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     *
     * @summary Get the account information on blockchain
     * @param {string} address Account address
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    authAccountsAddressGet(address, options) {
        return AuthApiFp(this.configuration).authAccountsAddressGet(address, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BankApi - axios parameter creator
 * @export
 */
export const BankApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        bankAccountsAddressTransfersPost: async (address, account, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('bankAccountsAddressTransfersPost', 'address', address);
            // verify required parameter 'account' is not null or undefined
            assertParamExists('bankAccountsAddressTransfersPost', 'account', account);
            const localVarPath = `/bank/accounts/{address}/transfers`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(account, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        bankBalancesAddressGet: async (address, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('bankBalancesAddressGet', 'address', address);
            const localVarPath = `/bank/balances/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        bankTotalDenominationGet: async (denomination, options = {}) => {
            // verify required parameter 'denomination' is not null or undefined
            assertParamExists('bankTotalDenominationGet', 'denomination', denomination);
            const localVarPath = `/bank/total/{denomination}`
                .replace(`{${"denomination"}}`, encodeURIComponent(String(denomination)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        bankTotalGet: async (options = {}) => {
            const localVarPath = `/bank/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BankApi - functional programming interface
 * @export
 */
export const BankApiFp = function (configuration) {
    const localVarAxiosParamCreator = BankApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async bankAccountsAddressTransfersPost(address, account, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankAccountsAddressTransfersPost(address, account, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async bankBalancesAddressGet(address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankBalancesAddressGet(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async bankTotalDenominationGet(denomination, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTotalDenominationGet(denomination, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async bankTotalGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankTotalGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * BankApi - factory interface
 * @export
 */
export const BankApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BankApiFp(configuration);
    return {
        /**
         *
         * @summary Send coins from one account to another
         * @param {string} address Account address in bech32 format
         * @param {InlineObject3} account
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        bankAccountsAddressTransfersPost(address, account, options) {
            return localVarFp.bankAccountsAddressTransfersPost(address, account, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the account balances
         * @param {string} address Account address in bech32 format
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        bankBalancesAddressGet(address, options) {
            return localVarFp.bankBalancesAddressGet(address, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Total supply of a single coin denomination
         * @param {string} denomination Coin denomination
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        bankTotalDenominationGet(denomination, options) {
            return localVarFp.bankTotalDenominationGet(denomination, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Total supply of coins in the chain
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        bankTotalGet(options) {
            return localVarFp.bankTotalGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BankApi - object-oriented interface
 * @export
 * @class BankApi
 * @extends {BaseAPI}
 */
export class BankApi extends BaseAPI {
    /**
     *
     * @summary Send coins from one account to another
     * @param {string} address Account address in bech32 format
     * @param {InlineObject3} account
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof BankApi
     */
    bankAccountsAddressTransfersPost(address, account, options) {
        return BankApiFp(this.configuration).bankAccountsAddressTransfersPost(address, account, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the account balances
     * @param {string} address Account address in bech32 format
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof BankApi
     */
    bankBalancesAddressGet(address, options) {
        return BankApiFp(this.configuration).bankBalancesAddressGet(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Total supply of a single coin denomination
     * @param {string} denomination Coin denomination
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof BankApi
     */
    bankTotalDenominationGet(denomination, options) {
        return BankApiFp(this.configuration).bankTotalDenominationGet(denomination, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Total supply of coins in the chain
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof BankApi
     */
    bankTotalGet(options) {
        return BankApiFp(this.configuration).bankTotalGet(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DistributionApi - axios parameter creator
 * @export
 */
export const DistributionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionCommunityPoolGet: async (options = {}) => {
            const localVarPath = `/distribution/community_pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsGet: async (delegatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('distributionDelegatorsDelegatorAddrRewardsGet', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsPost: async (delegatorAddr, withdrawRequestBody, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('distributionDelegatorsDelegatorAddrRewardsPost', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet: async (delegatorAddr, validatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet', 'delegatorAddr', delegatorAddr);
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost: async (delegatorAddr, validatorAddr, withdrawRequestBody, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost', 'delegatorAddr', delegatorAddr);
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost', 'validatorAddr', validatorAddr);
            const localVarPath = `/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressGet: async (delegatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('distributionDelegatorsDelegatorAddrWithdrawAddressGet', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/distribution/delegators/{delegatorAddr}/withdraw_address`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressPost: async (delegatorAddr, withdrawRequestBody, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('distributionDelegatorsDelegatorAddrWithdrawAddressPost', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/distribution/delegators/{delegatorAddr}/withdraw_address`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionParametersGet: async (options = {}) => {
            const localVarPath = `/distribution/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrGet: async (validatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('distributionValidatorsValidatorAddrGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/distribution/validators/{validatorAddr}`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrOutstandingRewardsGet: async (validatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('distributionValidatorsValidatorAddrOutstandingRewardsGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/distribution/validators/{validatorAddr}/outstanding_rewards`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsGet: async (validatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('distributionValidatorsValidatorAddrRewardsGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/distribution/validators/{validatorAddr}/rewards`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsPost: async (validatorAddr, withdrawRequestBody, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('distributionValidatorsValidatorAddrRewardsPost', 'validatorAddr', validatorAddr);
            const localVarPath = `/distribution/validators/{validatorAddr}/rewards`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * DistributionApi - functional programming interface
 * @export
 */
export const DistributionApiFp = function (configuration) {
    const localVarAxiosParamCreator = DistributionApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionCommunityPoolGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionCommunityPoolGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionParametersGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionParametersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionValidatorsValidatorAddrGet(validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionValidatorsValidatorAddrGet(validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * DistributionApi - factory interface
 * @export
 */
export const DistributionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DistributionApiFp(configuration);
    return {
        /**
         *
         * @summary Community pool parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionCommunityPoolGet(options) {
            return localVarFp.distributionCommunityPoolGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the sum of all the rewards earned by delegations by a single delegator
         * @summary Get the total rewards balance from all delegations
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options) {
            return localVarFp.distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw all the delegator\'s delegation rewards
         * @summary Withdraw all the delegator\'s delegation rewards
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject12} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options) {
            return localVarFp.distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query a single delegation reward by a delegator
         * @summary Query a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
            return localVarFp.distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw a delegator\'s delegation reward from a single validator
         * @summary Withdraw a delegation reward
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject13} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options) {
            return localVarFp.distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
         * @summary Get the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options) {
            return localVarFp.distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace the delegations\' rewards withdrawal address for a new one.
         * @summary Replace the rewards withdrawal address
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject14} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options) {
            return localVarFp.distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fee distribution parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionParametersGet(options) {
            return localVarFp.distributionParametersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Query the distribution information of a single validator
         * @summary Validator distribution information
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrGet(validatorAddr, options) {
            return localVarFp.distributionValidatorsValidatorAddrGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fee distribution outstanding rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options) {
            return localVarFp.distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Query the commission and self-delegation rewards of validator.
         * @summary Commission and self-delegation rewards of a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options) {
            return localVarFp.distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw the validator\'s self-delegation and commissions rewards
         * @summary Withdraw the validator\'s rewards
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {InlineObject15} [withdrawRequestBody]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options) {
            return localVarFp.distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DistributionApi - object-oriented interface
 * @export
 * @class DistributionApi
 * @extends {BaseAPI}
 */
export class DistributionApi extends BaseAPI {
    /**
     *
     * @summary Community pool parameters
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionCommunityPoolGet(options) {
        return DistributionApiFp(this.configuration).distributionCommunityPoolGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the sum of all the rewards earned by delegations by a single delegator
     * @summary Get the total rewards balance from all delegations
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrRewardsGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Withdraw all the delegator\'s delegation rewards
     * @summary Withdraw all the delegator\'s delegation rewards
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject12} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrRewardsPost(delegatorAddr, withdrawRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query a single delegation reward by a delegator
     * @summary Query a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Withdraw a delegator\'s delegation reward from a single validator
     * @summary Withdraw a delegation reward
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {InlineObject13} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrRewardsValidatorAddrPost(delegatorAddr, validatorAddr, withdrawRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the delegations\' rewards withdrawal address. This is the address in which the user will receive the reward funds
     * @summary Get the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrWithdrawAddressGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Replace the delegations\' rewards withdrawal address for a new one.
     * @summary Replace the rewards withdrawal address
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject14} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options) {
        return DistributionApiFp(this.configuration).distributionDelegatorsDelegatorAddrWithdrawAddressPost(delegatorAddr, withdrawRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fee distribution parameters
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionParametersGet(options) {
        return DistributionApiFp(this.configuration).distributionParametersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query the distribution information of a single validator
     * @summary Validator distribution information
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionValidatorsValidatorAddrGet(validatorAddr, options) {
        return DistributionApiFp(this.configuration).distributionValidatorsValidatorAddrGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fee distribution outstanding rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options) {
        return DistributionApiFp(this.configuration).distributionValidatorsValidatorAddrOutstandingRewardsGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query the commission and self-delegation rewards of validator.
     * @summary Commission and self-delegation rewards of a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options) {
        return DistributionApiFp(this.configuration).distributionValidatorsValidatorAddrRewardsGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Withdraw the validator\'s self-delegation and commissions rewards
     * @summary Withdraw the validator\'s rewards
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {InlineObject15} [withdrawRequestBody]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DistributionApi
     */
    distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options) {
        return DistributionApiFp(this.configuration).distributionValidatorsValidatorAddrRewardsPost(validatorAddr, withdrawRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GaiaRESTApi - axios parameter creator
 * @export
 */
export const GaiaRESTApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeInfoGet: async (options = {}) => {
            const localVarPath = `/node_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * GaiaRESTApi - functional programming interface
 * @export
 */
export const GaiaRESTApiFp = function (configuration) {
    const localVarAxiosParamCreator = GaiaRESTApiAxiosParamCreator(configuration);
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodeInfoGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodeInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * GaiaRESTApi - factory interface
 * @export
 */
export const GaiaRESTApiFactory = function (configuration, basePath, axios) {
    const localVarFp = GaiaRESTApiFp(configuration);
    return {
        /**
         * Information about the connected node
         * @summary The properties of the connected node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodeInfoGet(options) {
            return localVarFp.nodeInfoGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * GaiaRESTApi - object-oriented interface
 * @export
 * @class GaiaRESTApi
 * @extends {BaseAPI}
 */
export class GaiaRESTApi extends BaseAPI {
    /**
     * Information about the connected node
     * @summary The properties of the connected node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GaiaRESTApi
     */
    nodeInfoGet(options) {
        return GaiaRESTApiFp(this.configuration).nodeInfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GovernanceApi - axios parameter creator
 * @export
 */
export const GovernanceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govParametersDepositGet: async (options = {}) => {
            const localVarPath = `/gov/parameters/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govParametersTallyingGet: async (options = {}) => {
            const localVarPath = `/gov/parameters/tallying`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govParametersVotingGet: async (options = {}) => {
            const localVarPath = `/gov/parameters/voting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsGet: async (voter, depositor, status, options = {}) => {
            const localVarPath = `/gov/proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (voter !== undefined) {
                localVarQueryParameter['voter'] = voter;
            }
            if (depositor !== undefined) {
                localVarQueryParameter['depositor'] = depositor;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsParamChangePost: async (postProposalBody, options = {}) => {
            // verify required parameter 'postProposalBody' is not null or undefined
            assertParamExists('govProposalsParamChangePost', 'postProposalBody', postProposalBody);
            const localVarPath = `/gov/proposals/param_change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(postProposalBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsPost: async (postProposalBody, options = {}) => {
            // verify required parameter 'postProposalBody' is not null or undefined
            assertParamExists('govProposalsPost', 'postProposalBody', postProposalBody);
            const localVarPath = `/gov/proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(postProposalBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsDepositorGet: async (proposalId, depositor, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdDepositsDepositorGet', 'proposalId', proposalId);
            // verify required parameter 'depositor' is not null or undefined
            assertParamExists('govProposalsProposalIdDepositsDepositorGet', 'depositor', depositor);
            const localVarPath = `/gov/proposals/{proposalId}/deposits/{depositor}`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"depositor"}}`, encodeURIComponent(String(depositor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsGet: async (proposalId, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdDepositsGet', 'proposalId', proposalId);
            const localVarPath = `/gov/proposals/{proposalId}/deposits`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsPost: async (proposalId, postDepositBody, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdDepositsPost', 'proposalId', proposalId);
            // verify required parameter 'postDepositBody' is not null or undefined
            assertParamExists('govProposalsProposalIdDepositsPost', 'postDepositBody', postDepositBody);
            const localVarPath = `/gov/proposals/{proposalId}/deposits`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(postDepositBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdGet: async (proposalId, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdGet', 'proposalId', proposalId);
            const localVarPath = `/gov/proposals/{proposalId}`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdProposerGet: async (proposalId, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdProposerGet', 'proposalId', proposalId);
            const localVarPath = `/gov/proposals/{proposalId}/proposer`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdTallyGet: async (proposalId, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdTallyGet', 'proposalId', proposalId);
            const localVarPath = `/gov/proposals/{proposalId}/tally`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesGet: async (proposalId, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdVotesGet', 'proposalId', proposalId);
            const localVarPath = `/gov/proposals/{proposalId}/votes`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesPost: async (proposalId, postVoteBody, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdVotesPost', 'proposalId', proposalId);
            // verify required parameter 'postVoteBody' is not null or undefined
            assertParamExists('govProposalsProposalIdVotesPost', 'postVoteBody', postVoteBody);
            const localVarPath = `/gov/proposals/{proposalId}/votes`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(postVoteBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesVoterGet: async (proposalId, voter, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('govProposalsProposalIdVotesVoterGet', 'proposalId', proposalId);
            // verify required parameter 'voter' is not null or undefined
            assertParamExists('govProposalsProposalIdVotesVoterGet', 'voter', voter);
            const localVarPath = `/gov/proposals/{proposalId}/votes/{voter}`
                .replace(`{${"proposalId"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * GovernanceApi - functional programming interface
 * @export
 */
export const GovernanceApiFp = function (configuration) {
    const localVarAxiosParamCreator = GovernanceApiAxiosParamCreator(configuration);
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govParametersDepositGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govParametersDepositGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govParametersTallyingGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govParametersTallyingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govParametersVotingGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govParametersVotingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsGet(voter, depositor, status, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsGet(voter, depositor, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsParamChangePost(postProposalBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsParamChangePost(postProposalBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsPost(postProposalBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsPost(postProposalBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdDepositsGet(proposalId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdDepositsGet(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdGet(proposalId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdGet(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdProposerGet(proposalId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdProposerGet(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdTallyGet(proposalId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdTallyGet(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdVotesGet(proposalId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdVotesGet(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdVotesPost(proposalId, postVoteBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdVotesPost(proposalId, postVoteBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async govProposalsProposalIdVotesVoterGet(proposalId, voter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govProposalsProposalIdVotesVoterGet(proposalId, voter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * GovernanceApi - factory interface
 * @export
 */
export const GovernanceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = GovernanceApiFp(configuration);
    return {
        /**
         * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
         * @summary Query governance deposit parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govParametersDepositGet(options) {
            return localVarFp.govParametersDepositGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Query governance tally parameters
         * @summary Query governance tally parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govParametersTallyingGet(options) {
            return localVarFp.govParametersTallyingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Query governance voting parameters. The voting_period units are in nanoseconds.
         * @summary Query governance voting parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govParametersVotingGet(options) {
            return localVarFp.govParametersVotingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Query proposals information with parameters
         * @summary Query proposals
         * @param {string} [voter] voter address
         * @param {string} [depositor] depositor address
         * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsGet(voter, depositor, status, options) {
            return localVarFp.govProposalsGet(voter, depositor, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a parameter change proposal transaction
         * @summary Generate a parameter change proposal transaction
         * @param {InlineObject9} postProposalBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsParamChangePost(postProposalBody, options) {
            return localVarFp.govProposalsParamChangePost(postProposalBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Send transaction to submit a proposal
         * @summary Submit a proposal
         * @param {InlineObject8} postProposalBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsPost(postProposalBody, options) {
            return localVarFp.govProposalsPost(postProposalBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query deposit by proposalId and depositor address
         * @summary Query deposit
         * @param {string} proposalId proposal id
         * @param {string} depositor Bech32 depositor address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options) {
            return localVarFp.govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options).then((request) => request(axios, basePath));
        },
        /**
         * Query deposits by proposalId
         * @summary Query deposits
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsGet(proposalId, options) {
            return localVarFp.govProposalsProposalIdDepositsGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Send transaction to deposit tokens to a proposal
         * @summary Deposit tokens to a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject10} postDepositBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options) {
            return localVarFp.govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query a proposal by id
         * @summary Query a proposal
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdGet(proposalId, options) {
            return localVarFp.govProposalsProposalIdGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for the proposer for a proposal
         * @summary Query proposer
         * @param {string} proposalId
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdProposerGet(proposalId, options) {
            return localVarFp.govProposalsProposalIdProposerGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
         * @summary Get a proposal\'s tally result at the current time
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdTallyGet(proposalId, options) {
            return localVarFp.govProposalsProposalIdTallyGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Query voters information by proposalId
         * @summary Query voters
         * @param {string} proposalId proposal id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesGet(proposalId, options) {
            return localVarFp.govProposalsProposalIdVotesGet(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Send transaction to vote a proposal
         * @summary Vote a proposal
         * @param {string} proposalId proposal id
         * @param {InlineObject11} postVoteBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesPost(proposalId, postVoteBody, options) {
            return localVarFp.govProposalsProposalIdVotesPost(proposalId, postVoteBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Query vote information by proposal Id and voter address
         * @summary Query vote
         * @param {string} proposalId proposal id
         * @param {string} voter Bech32 voter address
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        govProposalsProposalIdVotesVoterGet(proposalId, voter, options) {
            return localVarFp.govProposalsProposalIdVotesVoterGet(proposalId, voter, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * GovernanceApi - object-oriented interface
 * @export
 * @class GovernanceApi
 * @extends {BaseAPI}
 */
export class GovernanceApi extends BaseAPI {
    /**
     * Query governance deposit parameters. The max_deposit_period units are in nanoseconds.
     * @summary Query governance deposit parameters
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govParametersDepositGet(options) {
        return GovernanceApiFp(this.configuration).govParametersDepositGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query governance tally parameters
     * @summary Query governance tally parameters
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govParametersTallyingGet(options) {
        return GovernanceApiFp(this.configuration).govParametersTallyingGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query governance voting parameters. The voting_period units are in nanoseconds.
     * @summary Query governance voting parameters
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govParametersVotingGet(options) {
        return GovernanceApiFp(this.configuration).govParametersVotingGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query proposals information with parameters
     * @summary Query proposals
     * @param {string} [voter] voter address
     * @param {string} [depositor] depositor address
     * @param {string} [status] proposal status, valid values can be &#x60;\&quot;deposit_period\&quot;&#x60;, &#x60;\&quot;voting_period\&quot;&#x60;, &#x60;\&quot;passed\&quot;&#x60;, &#x60;\&quot;rejected\&quot;&#x60;
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsGet(voter, depositor, status, options) {
        return GovernanceApiFp(this.configuration).govProposalsGet(voter, depositor, status, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generate a parameter change proposal transaction
     * @summary Generate a parameter change proposal transaction
     * @param {InlineObject9} postProposalBody
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsParamChangePost(postProposalBody, options) {
        return GovernanceApiFp(this.configuration).govProposalsParamChangePost(postProposalBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send transaction to submit a proposal
     * @summary Submit a proposal
     * @param {InlineObject8} postProposalBody
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsPost(postProposalBody, options) {
        return GovernanceApiFp(this.configuration).govProposalsPost(postProposalBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query deposit by proposalId and depositor address
     * @summary Query deposit
     * @param {string} proposalId proposal id
     * @param {string} depositor Bech32 depositor address
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdDepositsDepositorGet(proposalId, depositor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query deposits by proposalId
     * @summary Query deposits
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdDepositsGet(proposalId, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdDepositsGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send transaction to deposit tokens to a proposal
     * @summary Deposit tokens to a proposal
     * @param {string} proposalId proposal id
     * @param {InlineObject10} postDepositBody
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdDepositsPost(proposalId, postDepositBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query a proposal by id
     * @summary Query a proposal
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdGet(proposalId, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query for the proposer for a proposal
     * @summary Query proposer
     * @param {string} proposalId
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdProposerGet(proposalId, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdProposerGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a proposal\'s tally result at the current time. If the proposal is pending deposits (i.e status \'DepositPeriod\') it returns an empty tally result.
     * @summary Get a proposal\'s tally result at the current time
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdTallyGet(proposalId, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdTallyGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query voters information by proposalId
     * @summary Query voters
     * @param {string} proposalId proposal id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdVotesGet(proposalId, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdVotesGet(proposalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send transaction to vote a proposal
     * @summary Vote a proposal
     * @param {string} proposalId proposal id
     * @param {InlineObject11} postVoteBody
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdVotesPost(proposalId, postVoteBody, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdVotesPost(proposalId, postVoteBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query vote information by proposal Id and voter address
     * @summary Query vote
     * @param {string} proposalId proposal id
     * @param {string} voter Bech32 voter address
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GovernanceApi
     */
    govProposalsProposalIdVotesVoterGet(proposalId, voter, options) {
        return GovernanceApiFp(this.configuration).govProposalsProposalIdVotesVoterGet(proposalId, voter, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * MintApi - axios parameter creator
 * @export
 */
export const MintApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        mintingAnnualProvisionsGet: async (options = {}) => {
            const localVarPath = `/minting/annual-provisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        mintingInflationGet: async (options = {}) => {
            const localVarPath = `/minting/inflation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        mintingParametersGet: async (options = {}) => {
            const localVarPath = `/minting/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MintApi - functional programming interface
 * @export
 */
export const MintApiFp = function (configuration) {
    const localVarAxiosParamCreator = MintApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async mintingAnnualProvisionsGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintingAnnualProvisionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async mintingInflationGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintingInflationGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async mintingParametersGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintingParametersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MintApi - factory interface
 * @export
 */
export const MintApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MintApiFp(configuration);
    return {
        /**
         *
         * @summary Current minting annual provisions value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        mintingAnnualProvisionsGet(options) {
            return localVarFp.mintingAnnualProvisionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Current minting inflation value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        mintingInflationGet(options) {
            return localVarFp.mintingInflationGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Minting module parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        mintingParametersGet(options) {
            return localVarFp.mintingParametersGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MintApi - object-oriented interface
 * @export
 * @class MintApi
 * @extends {BaseAPI}
 */
export class MintApi extends BaseAPI {
    /**
     *
     * @summary Current minting annual provisions value
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MintApi
     */
    mintingAnnualProvisionsGet(options) {
        return MintApiFp(this.configuration).mintingAnnualProvisionsGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Current minting inflation value
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MintApi
     */
    mintingInflationGet(options) {
        return MintApiFp(this.configuration).mintingInflationGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Minting module parameters
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MintApi
     */
    mintingParametersGet(options) {
        return MintApiFp(this.configuration).mintingParametersGet(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account: async (address, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('account', 'address', address);
            const localVarPath = `/cosmos/auth/v1beta1/accounts/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts: async (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/auth/v1beta1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances: async (address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('allBalances', 'address', address);
            const localVarPath = `/cosmos/bank/v1beta1/balances/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence: async (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/evidence/v1beta1/evidence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowance: async (granter, grantee, options = {}) => {
            // verify required parameter 'granter' is not null or undefined
            assertParamExists('allowance', 'granter', granter);
            // verify required parameter 'grantee' is not null or undefined
            assertParamExists('allowance', 'grantee', grantee);
            const localVarPath = `/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}`
                .replace(`{${"granter"}}`, encodeURIComponent(String(granter)))
                .replace(`{${"grantee"}}`, encodeURIComponent(String(grantee)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowances: async (grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'grantee' is not null or undefined
            assertParamExists('allowances', 'grantee', grantee);
            const localVarPath = `/cosmos/feegrant/v1beta1/allowances/{grantee}`
                .replace(`{${"grantee"}}`, encodeURIComponent(String(grantee)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions: async (options = {}) => {
            const localVarPath = `/cosmos/mint/v1beta1/annual_provisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan: async (name, options = {}) => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('appliedPlan', 'name', name);
            const localVarPath = `/cosmos/upgrade/v1beta1/applied_plan/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams: async (options = {}) => {
            const localVarPath = `/cosmos/auth/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance: async (address, denom, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('balance', 'address', address);
            // verify required parameter 'denom' is not null or undefined
            assertParamExists('balance', 'denom', denom);
            const localVarPath = `/cosmos/bank/v1beta1/balances/{address}/{denom}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)))
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams: async (options = {}) => {
            const localVarPath = `/cosmos/bank/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool: async (options = {}) => {
            const localVarPath = `/cosmos/distribution/v1beta1/community_pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan: async (options = {}) => {
            const localVarPath = `/cosmos/upgrade/v1beta1/current_plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation: async (validatorAddr, delegatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('delegation', 'validatorAddr', validatorAddr);
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('delegation', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)))
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards: async (delegatorAddress, validatorAddress, options = {}) => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('delegationRewards', 'delegatorAddress', delegatorAddress);
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('delegationRewards', 'validatorAddress', validatorAddress);
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)))
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards: async (delegatorAddress, options = {}) => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('delegationTotalRewards', 'delegatorAddress', delegatorAddress);
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations: async (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('delegatorDelegations', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/delegations/{delegator_addr}`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations: async (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('delegatorUnbondingDelegations', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator: async (delegatorAddr, validatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('delegatorValidator', 'delegatorAddr', delegatorAddr);
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('delegatorValidator', 'validatorAddr', validatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators: async (delegatorAddress, options = {}) => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('delegatorValidators', 'delegatorAddress', delegatorAddress);
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress: async (delegatorAddress, options = {}) => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('delegatorWithdrawAddress', 'delegatorAddress', delegatorAddress);
            const localVarPath = `/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address`
                .replace(`{${"delegator_address"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomMetadata: async (denom, options = {}) => {
            // verify required parameter 'denom' is not null or undefined
            assertParamExists('denomMetadata', 'denom', denom);
            const localVarPath = `/cosmos/bank/v1beta1/denoms_metadata/{denom}`
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomOwners: async (denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'denom' is not null or undefined
            assertParamExists('denomOwners', 'denom', denom);
            const localVarPath = `/cosmos/bank/v1beta1/denom_owners/{denom}`
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomsMetadata: async (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/bank/v1beta1/denoms_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit: async (proposalId, depositor, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('deposit', 'proposalId', proposalId);
            // verify required parameter 'depositor' is not null or undefined
            assertParamExists('deposit', 'depositor', depositor);
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"depositor"}}`, encodeURIComponent(String(depositor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits: async (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('deposits', 'proposalId', proposalId);
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams: async (options = {}) => {
            const localVarPath = `/cosmos/distribution/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence: async (evidenceHash, options = {}) => {
            // verify required parameter 'evidenceHash' is not null or undefined
            assertParamExists('evidence', 'evidenceHash', evidenceHash);
            const localVarPath = `/cosmos/evidence/v1beta1/evidence/{evidence_hash}`
                .replace(`{${"evidence_hash"}}`, encodeURIComponent(String(evidenceHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams: async (paramsType, options = {}) => {
            // verify required parameter 'paramsType' is not null or undefined
            assertParamExists('govParams', 'paramsType', paramsType);
            const localVarPath = `/cosmos/gov/v1beta1/params/{params_type}`
                .replace(`{${"params_type"}}`, encodeURIComponent(String(paramsType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter]
         * @param {string} [grantee]
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grants: async (granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/authz/v1beta1/grants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (granter !== undefined) {
                localVarQueryParameter['granter'] = granter;
            }
            if (grantee !== undefined) {
                localVarQueryParameter['grantee'] = grantee;
            }
            if (msgTypeUrl !== undefined) {
                localVarQueryParameter['msg_type_url'] = msgTypeUrl;
            }
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo: async (height, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('historicalInfo', 'height', height);
            const localVarPath = `/cosmos/staking/v1beta1/historical_info/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation: async (options = {}) => {
            const localVarPath = `/cosmos/mint/v1beta1/inflation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams: async (options = {}) => {
            const localVarPath = `/cosmos/mint/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersions: async (moduleName, options = {}) => {
            const localVarPath = `/cosmos/upgrade/v1beta1/module_versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (moduleName !== undefined) {
                localVarQueryParameter['module_name'] = moduleName;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params: async (subspace, key, options = {}) => {
            const localVarPath = `/cosmos/params/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (subspace !== undefined) {
                localVarQueryParameter['subspace'] = subspace;
            }
            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool: async (options = {}) => {
            const localVarPath = `/cosmos/staking/v1beta1/pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal: async (proposalId, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('proposal', 'proposalId', proposalId);
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals: async (proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/gov/v1beta1/proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (proposalStatus !== undefined) {
                localVarQueryParameter['proposal_status'] = proposalStatus;
            }
            if (voter !== undefined) {
                localVarQueryParameter['voter'] = voter;
            }
            if (depositor !== undefined) {
                localVarQueryParameter['depositor'] = depositor;
            }
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations: async (delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('redelegations', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (srcValidatorAddr !== undefined) {
                localVarQueryParameter['src_validator_addr'] = srcValidatorAddr;
            }
            if (dstValidatorAddr !== undefined) {
                localVarQueryParameter['dst_validator_addr'] = dstValidatorAddr;
            }
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo: async (consAddress, options = {}) => {
            // verify required parameter 'consAddress' is not null or undefined
            assertParamExists('signingInfo', 'consAddress', consAddress);
            const localVarPath = `/cosmos/slashing/v1beta1/signing_infos/{cons_address}`
                .replace(`{${"cons_address"}}`, encodeURIComponent(String(consAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos: async (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/slashing/v1beta1/signing_infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams: async (options = {}) => {
            const localVarPath = `/cosmos/slashing/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators: async (delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorValidators', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators`
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams: async (options = {}) => {
            const localVarPath = `/cosmos/staking/v1beta1/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf: async (denom, options = {}) => {
            // verify required parameter 'denom' is not null or undefined
            assertParamExists('supplyOf', 'denom', denom);
            const localVarPath = `/cosmos/bank/v1beta1/supply/{denom}`
                .replace(`{${"denom"}}`, encodeURIComponent(String(denom)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult: async (proposalId, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('tallyResult', 'proposalId', proposalId);
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/tally`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply: async (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/bank/v1beta1/supply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation: async (validatorAddr, delegatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('unbondingDelegation', 'validatorAddr', validatorAddr);
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('unbondingDelegation', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)))
                .replace(`{${"delegator_addr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState: async (lastHeight, options = {}) => {
            // verify required parameter 'lastHeight' is not null or undefined
            assertParamExists('upgradedConsensusState', 'lastHeight', lastHeight);
            const localVarPath = `/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}`
                .replace(`{${"last_height"}}`, encodeURIComponent(String(lastHeight)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator: async (validatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('validator', 'validatorAddr', validatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission: async (validatorAddress, options = {}) => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('validatorCommission', 'validatorAddress', validatorAddress);
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/commission`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations: async (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('validatorDelegations', 'validatorAddr', validatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/delegations`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards: async (validatorAddress, options = {}) => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('validatorOutstandingRewards', 'validatorAddress', validatorAddress);
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('validatorSlashes', 'validatorAddress', validatorAddress);
            const localVarPath = `/cosmos/distribution/v1beta1/validators/{validator_address}/slashes`
                .replace(`{${"validator_address"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (startingHeight !== undefined) {
                localVarQueryParameter['starting_height'] = startingHeight;
            }
            if (endingHeight !== undefined) {
                localVarQueryParameter['ending_height'] = endingHeight;
            }
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations: async (validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('validatorUnbondingDelegations', 'validatorAddr', validatorAddr);
            const localVarPath = `/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations`
                .replace(`{${"validator_addr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators: async (status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/staking/v1beta1/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote: async (proposalId, voter, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('vote', 'proposalId', proposalId);
            // verify required parameter 'voter' is not null or undefined
            assertParamExists('vote', 'voter', voter);
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)))
                .replace(`{${"voter"}}`, encodeURIComponent(String(voter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes: async (proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'proposalId' is not null or undefined
            assertParamExists('votes', 'proposalId', proposalId);
            const localVarPath = `/cosmos/gov/v1beta1/proposals/{proposal_id}/votes`
                .replace(`{${"proposal_id"}}`, encodeURIComponent(String(proposalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function (configuration) {
    const localVarAxiosParamCreator = QueryApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async account(address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.account(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowance(granter, grantee, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowance(granter, grantee, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async annualProvisions(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.annualProvisions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appliedPlan(name, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appliedPlan(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authParams(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balance(address, denom, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.balance(address, denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bankParams(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bankParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async communityPool(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.communityPool(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentPlan(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentPlan(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegation(validatorAddr, delegatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegation(validatorAddr, delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegationRewards(delegatorAddress, validatorAddress, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegationRewards(delegatorAddress, validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegationTotalRewards(delegatorAddress, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegationTotalRewards(delegatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorValidator(delegatorAddr, validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorValidator(delegatorAddr, validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorValidators(delegatorAddress, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorValidators(delegatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delegatorWithdrawAddress(delegatorAddress, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delegatorWithdrawAddress(delegatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomMetadata(denom, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomMetadata(denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposit(proposalId, depositor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposit(proposalId, depositor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distributionParams(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distributionParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evidence(evidenceHash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evidence(evidenceHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async govParams(paramsType, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.govParams(paramsType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter]
         * @param {string} [grantee]
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async historicalInfo(height, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.historicalInfo(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inflation(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inflation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mintParams(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mintParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleVersions(moduleName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleVersions(moduleName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async params(subspace, key, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.params(subspace, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pool(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pool(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proposal(proposalId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proposal(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signingInfo(consAddress, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signingInfo(consAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async slashingParams(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slashingParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingParams(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supplyOf(denom, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supplyOf(denom, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tallyResult(proposalId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tallyResult(proposalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbondingDelegation(validatorAddr, delegatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbondingDelegation(validatorAddr, delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradedConsensusState(lastHeight, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradedConsensusState(lastHeight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validator(validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validator(validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorCommission(validatorAddress, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorCommission(validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorOutstandingRewards(validatorAddress, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorOutstandingRewards(validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vote(proposalId, voter, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vote(proposalId, voter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = QueryApiFp(configuration);
    return {
        /**
         *
         * @summary Account returns account details based on address.
         * @param {string} address address defines the address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account(address, options) {
            return localVarFp.account(address, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Accounts returns all the existing accounts
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary AllBalances queries the balance of all coins for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary AllEvidence queries all evidence.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Allowance returns fee granted to the grantee by the granter.
         * @param {string} granter granter is the address of the user granting an allowance of their funds.
         * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowance(granter, grantee, options) {
            return localVarFp.allowance(granter, grantee, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Allowances returns all the grants for address.
         * @param {string} grantee
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary AnnualProvisions current minting annual provisions value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        annualProvisions(options) {
            return localVarFp.annualProvisions(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary AppliedPlan queries a previously applied upgrade plan by its name.
         * @param {string} name name is the name of the applied plan to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appliedPlan(name, options) {
            return localVarFp.appliedPlan(name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Params queries all parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authParams(options) {
            return localVarFp.authParams(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Balance queries the balance of a single coin for a single account.
         * @param {string} address address is the address to query balances for.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balance(address, denom, options) {
            return localVarFp.balance(address, denom, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Params queries the parameters of x/bank module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bankParams(options) {
            return localVarFp.bankParams(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary CommunityPool queries the community pool coins.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        communityPool(options) {
            return localVarFp.communityPool(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary CurrentPlan queries the current upgrade plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentPlan(options) {
            return localVarFp.currentPlan(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delegation queries delegate info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegation(validatorAddr, delegatorAddr, options) {
            return localVarFp.delegation(validatorAddr, delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DelegationRewards queries the total rewards accrued by a delegation.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationRewards(delegatorAddress, validatorAddress, options) {
            return localVarFp.delegationRewards(delegatorAddress, validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegationTotalRewards(delegatorAddress, options) {
            return localVarFp.delegationTotalRewards(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DelegatorDelegations queries all delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DelegatorValidator queries validator info for given delegator validator pair.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidator(delegatorAddr, validatorAddr, options) {
            return localVarFp.delegatorValidator(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DelegatorValidators queries the validators of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorValidators(delegatorAddress, options) {
            return localVarFp.delegatorValidators(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
         * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegatorWithdrawAddress(delegatorAddress, options) {
            return localVarFp.delegatorWithdrawAddress(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata of a given coin denomination.
         * @param {string} denom denom is the coin denom to query the metadata for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomMetadata(denom, options) {
            return localVarFp.denomMetadata(denom, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DenomOwners queries for all account addresses that own a particular token denomination.
         * @param {string} denom denom defines the coin denomination to query all account holders for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deposit queries single deposit information based proposalID, depositAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} depositor depositor defines the deposit addresses from the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposit(proposalId, depositor, options) {
            return localVarFp.deposit(proposalId, depositor, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deposits queries all deposits of a single proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Params queries params of the distribution module.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distributionParams(options) {
            return localVarFp.distributionParams(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Evidence queries evidence based on evidence hash.
         * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evidence(evidenceHash, options) {
            return localVarFp.evidence(evidenceHash, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Params queries all parameters of the gov module.
         * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        govParams(paramsType, options) {
            return localVarFp.govParams(paramsType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns list of `Authorization`, granted to the grantee by the granter.
         * @param {string} [granter]
         * @param {string} [grantee]
         * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary HistoricalInfo queries the historical info for given height.
         * @param {string} height height defines at which height to query the historical info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historicalInfo(height, options) {
            return localVarFp.historicalInfo(height, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Inflation returns the current minting inflation value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inflation(options) {
            return localVarFp.inflation(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Params returns the total set of minting parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintParams(options) {
            return localVarFp.mintParams(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary ModuleVersions queries the list of module versions from state.
         * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersions(moduleName, options) {
            return localVarFp.moduleVersions(moduleName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Params queries a specific parameter of a module, given its subspace and key.
         * @param {string} [subspace] subspace defines the module to query the parameter for.
         * @param {string} [key] key defines the key of the parameter in the subspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        params(subspace, key, options) {
            return localVarFp.params(subspace, key, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Pool queries the pool info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pool(options) {
            return localVarFp.pool(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Proposal queries proposal details based on ProposalID.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposal(proposalId, options) {
            return localVarFp.proposal(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Proposals queries all proposals based on given status.
         * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
         * @param {string} [voter] voter defines the voter address for the proposals.
         * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Redelegations queries redelegations of given address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
         * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary SigningInfo queries the signing info of given cons address
         * @param {string} consAddress cons_address is the address to query signing info of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfo(consAddress, options) {
            return localVarFp.signingInfo(consAddress, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary SigningInfos queries signing info of all validators
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Params queries the parameters of slashing module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        slashingParams(options) {
            return localVarFp.slashingParams(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary DelegatorValidators queries all validators info for given delegator address.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Parameters queries the staking parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingParams(options) {
            return localVarFp.stakingParams(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary SupplyOf queries the supply of a single coin.
         * @param {string} denom denom is the coin denom to query balances for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supplyOf(denom, options) {
            return localVarFp.supplyOf(denom, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary TallyResult queries the tally of a proposal vote.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tallyResult(proposalId, options) {
            return localVarFp.tallyResult(proposalId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary TotalSupply queries the total supply of all coins.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbondingDelegation(validatorAddr, delegatorAddr, options) {
            return localVarFp.unbondingDelegation(validatorAddr, delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
         * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradedConsensusState(lastHeight, options) {
            return localVarFp.upgradedConsensusState(lastHeight, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validator queries validator info for given validator address.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validator(validatorAddr, options) {
            return localVarFp.validator(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary ValidatorCommission queries accumulated commission for a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorCommission(validatorAddress, options) {
            return localVarFp.validatorCommission(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary ValidatorDelegations queries delegate info for given validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary ValidatorOutstandingRewards queries rewards of a validator address.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorOutstandingRewards(validatorAddress, options) {
            return localVarFp.validatorOutstandingRewards(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary ValidatorSlashes queries slash events of a validator.
         * @param {string} validatorAddress validator_address defines the validator address to query for.
         * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
         * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
         * @param {string} validatorAddr validator_addr defines the validator address to query for.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validators queries all validators that match the given status.
         * @param {string} [status] status enables to query for validators matching a given status.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Vote queries voted information based on proposalID, voterAddr.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} voter voter defines the oter address for the proposals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vote(proposalId, voter, options) {
            return localVarFp.vote(proposalId, voter, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Votes queries votes of a given proposal.
         * @param {string} proposalId proposal_id defines the unique id of the proposal.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     *
     * @summary Account returns account details based on address.
     * @param {string} address address defines the address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    account(address, options) {
        return QueryApiFp(this.configuration).account(address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Accounts returns all the existing accounts
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).accounts(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary AllBalances queries the balance of all coins for a single account.
     * @param {string} address address is the address to query balances for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).allBalances(address, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary AllEvidence queries all evidence.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).allEvidence(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Allowance returns fee granted to the grantee by the granter.
     * @param {string} granter granter is the address of the user granting an allowance of their funds.
     * @param {string} grantee grantee is the address of the user being granted an allowance of another user\&#39;s funds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    allowance(granter, grantee, options) {
        return QueryApiFp(this.configuration).allowance(granter, grantee, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Allowances returns all the grants for address.
     * @param {string} grantee
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).allowances(grantee, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary AnnualProvisions current minting annual provisions value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    annualProvisions(options) {
        return QueryApiFp(this.configuration).annualProvisions(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary AppliedPlan queries a previously applied upgrade plan by its name.
     * @param {string} name name is the name of the applied plan to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    appliedPlan(name, options) {
        return QueryApiFp(this.configuration).appliedPlan(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Params queries all parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    authParams(options) {
        return QueryApiFp(this.configuration).authParams(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Balance queries the balance of a single coin for a single account.
     * @param {string} address address is the address to query balances for.
     * @param {string} denom denom is the coin denom to query balances for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    balance(address, denom, options) {
        return QueryApiFp(this.configuration).balance(address, denom, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Params queries the parameters of x/bank module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    bankParams(options) {
        return QueryApiFp(this.configuration).bankParams(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary CommunityPool queries the community pool coins.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    communityPool(options) {
        return QueryApiFp(this.configuration).communityPool(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary CurrentPlan queries the current upgrade plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    currentPlan(options) {
        return QueryApiFp(this.configuration).currentPlan(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delegation queries delegate info for given validator delegator pair.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    delegation(validatorAddr, delegatorAddr, options) {
        return QueryApiFp(this.configuration).delegation(validatorAddr, delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DelegationRewards queries the total rewards accrued by a delegation.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    delegationRewards(delegatorAddress, validatorAddress, options) {
        return QueryApiFp(this.configuration).delegationRewards(delegatorAddress, validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DelegationTotalRewards queries the total rewards accrued by a each validator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    delegationTotalRewards(delegatorAddress, options) {
        return QueryApiFp(this.configuration).delegationTotalRewards(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DelegatorDelegations queries all delegations of a given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).delegatorDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DelegatorUnbondingDelegations queries all unbonding delegations of a given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).delegatorUnbondingDelegations(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DelegatorValidator queries validator info for given delegator validator pair.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    delegatorValidator(delegatorAddr, validatorAddr, options) {
        return QueryApiFp(this.configuration).delegatorValidator(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DelegatorValidators queries the validators of a delegator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    delegatorValidators(delegatorAddress, options) {
        return QueryApiFp(this.configuration).delegatorValidators(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DelegatorWithdrawAddress queries withdraw address of a delegator.
     * @param {string} delegatorAddress delegator_address defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    delegatorWithdrawAddress(delegatorAddress, options) {
        return QueryApiFp(this.configuration).delegatorWithdrawAddress(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DenomsMetadata queries the client metadata of a given coin denomination.
     * @param {string} denom denom is the coin denom to query the metadata for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    denomMetadata(denom, options) {
        return QueryApiFp(this.configuration).denomMetadata(denom, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DenomOwners queries for all account addresses that own a particular token denomination.
     * @param {string} denom denom defines the coin denomination to query all account holders for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).denomOwners(denom, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DenomsMetadata queries the client metadata for all registered coin denominations.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).denomsMetadata(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deposit queries single deposit information based proposalID, depositAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} depositor depositor defines the deposit addresses from the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    deposit(proposalId, depositor, options) {
        return QueryApiFp(this.configuration).deposit(proposalId, depositor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deposits queries all deposits of a single proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).deposits(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Params queries params of the distribution module.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    distributionParams(options) {
        return QueryApiFp(this.configuration).distributionParams(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Evidence queries evidence based on evidence hash.
     * @param {string} evidenceHash evidence_hash defines the hash of the requested evidence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    evidence(evidenceHash, options) {
        return QueryApiFp(this.configuration).evidence(evidenceHash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Params queries all parameters of the gov module.
     * @param {string} paramsType params_type defines which parameters to query for, can be one of \&quot;voting\&quot;, \&quot;tallying\&quot; or \&quot;deposit\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    govParams(paramsType, options) {
        return QueryApiFp(this.configuration).govParams(paramsType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns list of `Authorization`, granted to the grantee by the granter.
     * @param {string} [granter]
     * @param {string} [grantee]
     * @param {string} [msgTypeUrl] Optional, msg_type_url, when set, will query only grants matching given msg type.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).grants(granter, grantee, msgTypeUrl, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary HistoricalInfo queries the historical info for given height.
     * @param {string} height height defines at which height to query the historical info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    historicalInfo(height, options) {
        return QueryApiFp(this.configuration).historicalInfo(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Inflation returns the current minting inflation value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    inflation(options) {
        return QueryApiFp(this.configuration).inflation(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Params returns the total set of minting parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    mintParams(options) {
        return QueryApiFp(this.configuration).mintParams(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary ModuleVersions queries the list of module versions from state.
     * @param {string} [moduleName] module_name is a field to query a specific module consensus version from state. Leaving this empty will fetch the full list of module versions from state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    moduleVersions(moduleName, options) {
        return QueryApiFp(this.configuration).moduleVersions(moduleName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Params queries a specific parameter of a module, given its subspace and key.
     * @param {string} [subspace] subspace defines the module to query the parameter for.
     * @param {string} [key] key defines the key of the parameter in the subspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    params(subspace, key, options) {
        return QueryApiFp(this.configuration).params(subspace, key, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Pool queries the pool info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    pool(options) {
        return QueryApiFp(this.configuration).pool(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Proposal queries proposal details based on ProposalID.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    proposal(proposalId, options) {
        return QueryApiFp(this.configuration).proposal(proposalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Proposals queries all proposals based on given status.
     * @param {'PROPOSAL_STATUS_UNSPECIFIED' | 'PROPOSAL_STATUS_DEPOSIT_PERIOD' | 'PROPOSAL_STATUS_VOTING_PERIOD' | 'PROPOSAL_STATUS_PASSED' | 'PROPOSAL_STATUS_REJECTED' | 'PROPOSAL_STATUS_FAILED'} [proposalStatus] proposal_status defines the status of the proposals.   - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit period.  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting period.  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has passed.  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has been rejected.  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has failed.
     * @param {string} [voter] voter defines the voter address for the proposals.
     * @param {string} [depositor] depositor defines the deposit addresses from the proposals.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).proposals(proposalStatus, voter, depositor, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Redelegations queries redelegations of given address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [srcValidatorAddr] src_validator_addr defines the validator address to redelegate from.
     * @param {string} [dstValidatorAddr] dst_validator_addr defines the validator address to redelegate to.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).redelegations(delegatorAddr, srcValidatorAddr, dstValidatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary SigningInfo queries the signing info of given cons address
     * @param {string} consAddress cons_address is the address to query signing info of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    signingInfo(consAddress, options) {
        return QueryApiFp(this.configuration).signingInfo(consAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary SigningInfos queries signing info of all validators
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).signingInfos(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Params queries the parameters of slashing module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    slashingParams(options) {
        return QueryApiFp(this.configuration).slashingParams(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary DelegatorValidators queries all validators info for given delegator address.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).stakingDelegatorValidators(delegatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Parameters queries the staking parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    stakingParams(options) {
        return QueryApiFp(this.configuration).stakingParams(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary SupplyOf queries the supply of a single coin.
     * @param {string} denom denom is the coin denom to query balances for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    supplyOf(denom, options) {
        return QueryApiFp(this.configuration).supplyOf(denom, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary TallyResult queries the tally of a proposal vote.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    tallyResult(proposalId, options) {
        return QueryApiFp(this.configuration).tallyResult(proposalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary TotalSupply queries the total supply of all coins.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).totalSupply(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary UnbondingDelegation queries unbonding info for given validator delegator pair.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} delegatorAddr delegator_addr defines the delegator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    unbondingDelegation(validatorAddr, delegatorAddr, options) {
        return QueryApiFp(this.configuration).unbondingDelegation(validatorAddr, delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary UpgradedConsensusState queries the consensus state that will serve as a trusted kernel for the next version of this chain. It will only be stored at the last height of this chain. UpgradedConsensusState RPC not supported with legacy querier
     * @param {string} lastHeight last height of the current chain must be sent in request as this is the height under which next consensus state is stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    upgradedConsensusState(lastHeight, options) {
        return QueryApiFp(this.configuration).upgradedConsensusState(lastHeight, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Validator queries validator info for given validator address.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    validator(validatorAddr, options) {
        return QueryApiFp(this.configuration).validator(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary ValidatorCommission queries accumulated commission for a validator.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    validatorCommission(validatorAddress, options) {
        return QueryApiFp(this.configuration).validatorCommission(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary ValidatorDelegations queries delegate info for given validator.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).validatorDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary ValidatorOutstandingRewards queries rewards of a validator address.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    validatorOutstandingRewards(validatorAddress, options) {
        return QueryApiFp(this.configuration).validatorOutstandingRewards(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary ValidatorSlashes queries slash events of a validator.
     * @param {string} validatorAddress validator_address defines the validator address to query for.
     * @param {string} [startingHeight] starting_height defines the optional starting height to query the slashes.
     * @param {string} [endingHeight] starting_height defines the optional ending height to query the slashes.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).validatorSlashes(validatorAddress, startingHeight, endingHeight, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary ValidatorUnbondingDelegations queries unbonding delegations of a validator.
     * @param {string} validatorAddr validator_addr defines the validator address to query for.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).validatorUnbondingDelegations(validatorAddr, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Validators queries all validators that match the given status.
     * @param {string} [status] status enables to query for validators matching a given status.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).validators(status, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Vote queries voted information based on proposalID, voterAddr.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} voter voter defines the oter address for the proposals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    vote(proposalId, voter, options) {
        return QueryApiFp(this.configuration).vote(proposalId, voter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Votes queries votes of a given proposal.
     * @param {string} proposalId proposal_id defines the unique id of the proposal.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return QueryApiFp(this.configuration).votes(proposalId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ServiceApi - axios parameter creator
 * @export
 */
export const ServiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('broadcastTx', 'body', body);
            const localVarPath = `/cosmos/tx/v1beta1/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight: async (height, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getBlockByHeight', 'height', height);
            const localVarPath = `/cosmos/base/tendermint/v1beta1/blocks/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock: async (options = {}) => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/blocks/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet: async (paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/validatorsets/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: async (options = {}) => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/node_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing: async (options = {}) => {
            const localVarPath = `/cosmos/base/tendermint/v1beta1/syncing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx: async (hash, options = {}) => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getTx', 'hash', hash);
            const localVarPath = `/cosmos/tx/v1beta1/txs/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent: async (events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options = {}) => {
            const localVarPath = `/cosmos/tx/v1beta1/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (events) {
                localVarQueryParameter['events'] = events;
            }
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight: async (height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getValidatorSetByHeight', 'height', height);
            const localVarPath = `/cosmos/base/tendermint/v1beta1/validatorsets/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }
            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }
            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }
            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }
            if (paginationReverse !== undefined) {
                localVarQueryParameter['pagination.reverse'] = paginationReverse;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('simulate', 'body', body);
            const localVarPath = `/cosmos/tx/v1beta1/simulate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ServiceApi - functional programming interface
 * @export
 */
export const ServiceApiFp = function (configuration) {
    const localVarAxiosParamCreator = ServiceApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async broadcastTx(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTx(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeight(height, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockByHeight(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestBlock(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestBlock(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeInfo(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncing(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSyncing(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTx(hash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTx(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulate(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ServiceApi - factory interface
 * @export
 */
export const ServiceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ServiceApiFp(configuration);
    return {
        /**
         *
         * @summary BroadcastTx broadcast transaction.
         * @param {InlineObject16} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        broadcastTx(body, options) {
            return localVarFp.broadcastTx(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetBlockByHeight queries block for given height.
         * @param {string} height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight(height, options) {
            return localVarFp.getBlockByHeight(height, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetLatestBlock returns the latest block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestBlock(options) {
            return localVarFp.getLatestBlock(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetLatestValidatorSet queries latest validator-set.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetNodeInfo queries the current node info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo(options) {
            return localVarFp.getNodeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetSyncing queries node syncing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncing(options) {
            return localVarFp.getSyncing(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetTx fetches a tx by hash.
         * @param {string} hash hash is the tx hash to query, encoded as a hex string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTx(hash, options) {
            return localVarFp.getTx(hash, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetTxsEvent fetches txs by event.
         * @param {Array<string>} [events] events is the list of transaction event type.
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options) {
            return localVarFp.getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary GetValidatorSetByHeight queries validator-set at a given height.
         * @param {string} height
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
            return localVarFp.getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Simulate simulates executing a transaction for estimating gas usage.
         * @param {CosmosTxV1beta1SimulateRequest} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulate(body, options) {
            return localVarFp.simulate(body, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ServiceApi - object-oriented interface
 * @export
 * @class ServiceApi
 * @extends {BaseAPI}
 */
export class ServiceApi extends BaseAPI {
    /**
     *
     * @summary BroadcastTx broadcast transaction.
     * @param {InlineObject16} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    broadcastTx(body, options) {
        return ServiceApiFp(this.configuration).broadcastTx(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetBlockByHeight queries block for given height.
     * @param {string} height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    getBlockByHeight(height, options) {
        return ServiceApiFp(this.configuration).getBlockByHeight(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetLatestBlock returns the latest block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    getLatestBlock(options) {
        return ServiceApiFp(this.configuration).getLatestBlock(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetLatestValidatorSet queries latest validator-set.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return ServiceApiFp(this.configuration).getLatestValidatorSet(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetNodeInfo queries the current node info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    getNodeInfo(options) {
        return ServiceApiFp(this.configuration).getNodeInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetSyncing queries node syncing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    getSyncing(options) {
        return ServiceApiFp(this.configuration).getSyncing(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetTx fetches a tx by hash.
     * @param {string} hash hash is the tx hash to query, encoded as a hex string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    getTx(hash, options) {
        return ServiceApiFp(this.configuration).getTx(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetTxsEvent fetches txs by event.
     * @param {Array<string>} [events] events is the list of transaction event type.
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {'ORDER_BY_UNSPECIFIED' | 'ORDER_BY_ASC' | 'ORDER_BY_DESC'} [orderBy]  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options) {
        return ServiceApiFp(this.configuration).getTxsEvent(events, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, orderBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary GetValidatorSetByHeight queries validator-set at a given height.
     * @param {string} height
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {boolean} [paginationReverse] reverse is set to true if results are to be returned in the descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options) {
        return ServiceApiFp(this.configuration).getValidatorSetByHeight(height, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, paginationReverse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Simulate simulates executing a transaction for estimating gas usage.
     * @param {CosmosTxV1beta1SimulateRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceApi
     */
    simulate(body, options) {
        return ServiceApiFp(this.configuration).simulate(body, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SlashingApi - axios parameter creator
 * @export
 */
export const SlashingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slashingParametersGet: async (options = {}) => {
            const localVarPath = `/slashing/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slashingSigningInfosGet: async (page, limit, options = {}) => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('slashingSigningInfosGet', 'page', page);
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('slashingSigningInfosGet', 'limit', limit);
            const localVarPath = `/slashing/signing_infos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slashingValidatorsValidatorAddrUnjailPost: async (validatorAddr, unjailBody, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('slashingValidatorsValidatorAddrUnjailPost', 'validatorAddr', validatorAddr);
            // verify required parameter 'unjailBody' is not null or undefined
            assertParamExists('slashingValidatorsValidatorAddrUnjailPost', 'unjailBody', unjailBody);
            const localVarPath = `/slashing/validators/{validatorAddr}/unjail`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(unjailBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SlashingApi - functional programming interface
 * @export
 */
export const SlashingApiFp = function (configuration) {
    const localVarAxiosParamCreator = SlashingApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slashingParametersGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slashingParametersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slashingSigningInfosGet(page, limit, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slashingSigningInfosGet(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * SlashingApi - factory interface
 * @export
 */
export const SlashingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SlashingApiFp(configuration);
    return {
        /**
         *
         * @summary Get the current slashing parameters
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slashingParametersGet(options) {
            return localVarFp.slashingParametersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get sign info of all validators
         * @summary Get sign info of given all validators
         * @param {number} page Page number
         * @param {number} limit Maximum number of items per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slashingSigningInfosGet(page, limit, options) {
            return localVarFp.slashingSigningInfosGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Send transaction to unjail a jailed validator
         * @summary Unjail a jailed validator
         * @param {string} validatorAddr Bech32 validator address
         * @param {InlineObject7} unjailBody
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options) {
            return localVarFp.slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SlashingApi - object-oriented interface
 * @export
 * @class SlashingApi
 * @extends {BaseAPI}
 */
export class SlashingApi extends BaseAPI {
    /**
     *
     * @summary Get the current slashing parameters
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    slashingParametersGet(options) {
        return SlashingApiFp(this.configuration).slashingParametersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get sign info of all validators
     * @summary Get sign info of given all validators
     * @param {number} page Page number
     * @param {number} limit Maximum number of items per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    slashingSigningInfosGet(page, limit, options) {
        return SlashingApiFp(this.configuration).slashingSigningInfosGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send transaction to unjail a jailed validator
     * @summary Unjail a jailed validator
     * @param {string} validatorAddr Bech32 validator address
     * @param {InlineObject7} unjailBody
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SlashingApi
     */
    slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options) {
        return SlashingApiFp(this.configuration).slashingValidatorsValidatorAddrUnjailPost(validatorAddr, unjailBody, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * StakingApi - axios parameter creator
 * @export
 */
export const StakingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsGet: async (delegatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrDelegationsGet', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/delegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsPost: async (delegatorAddr, delegation, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrDelegationsPost', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/delegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(delegation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet: async (delegatorAddr, validatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet', 'delegatorAddr', delegatorAddr);
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/delegations/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrRedelegationsPost: async (delegatorAddr, delegation, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrRedelegationsPost', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/redelegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(delegation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsGet: async (delegatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrUnbondingDelegationsGet', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsPost: async (delegatorAddr, delegation, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrUnbondingDelegationsPost', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(delegation, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet: async (delegatorAddr, validatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet', 'delegatorAddr', delegatorAddr);
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/unbonding_delegations/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsGet: async (delegatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrValidatorsGet', 'delegatorAddr', delegatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/validators`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet: async (delegatorAddr, validatorAddr, options = {}) => {
            // verify required parameter 'delegatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet', 'delegatorAddr', delegatorAddr);
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/staking/delegators/{delegatorAddr}/validators/{validatorAddr}`
                .replace(`{${"delegatorAddr"}}`, encodeURIComponent(String(delegatorAddr)))
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingParametersGet: async (options = {}) => {
            const localVarPath = `/staking/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingPoolGet: async (options = {}) => {
            const localVarPath = `/staking/pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingRedelegationsGet: async (delegator, validatorFrom, validatorTo, options = {}) => {
            const localVarPath = `/staking/redelegations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (delegator !== undefined) {
                localVarQueryParameter['delegator'] = delegator;
            }
            if (validatorFrom !== undefined) {
                localVarQueryParameter['validator_from'] = validatorFrom;
            }
            if (validatorTo !== undefined) {
                localVarQueryParameter['validator_to'] = validatorTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingValidatorsGet: async (status, page, limit, options = {}) => {
            const localVarPath = `/staking/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrDelegationsGet: async (validatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('stakingValidatorsValidatorAddrDelegationsGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/staking/validators/{validatorAddr}/delegations`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrGet: async (validatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('stakingValidatorsValidatorAddrGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/staking/validators/{validatorAddr}`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrUnbondingDelegationsGet: async (validatorAddr, options = {}) => {
            // verify required parameter 'validatorAddr' is not null or undefined
            assertParamExists('stakingValidatorsValidatorAddrUnbondingDelegationsGet', 'validatorAddr', validatorAddr);
            const localVarPath = `/staking/validators/{validatorAddr}/unbonding_delegations`
                .replace(`{${"validatorAddr"}}`, encodeURIComponent(String(validatorAddr)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StakingApi - functional programming interface
 * @export
 */
export const StakingApiFp = function (configuration) {
    const localVarAxiosParamCreator = StakingApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingParametersGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingParametersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingPoolGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingPoolGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingValidatorsGet(status, page, limit, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingValidatorsGet(status, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingValidatorsValidatorAddrGet(validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingValidatorsValidatorAddrGet(validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * StakingApi - factory interface
 * @export
 */
export const StakingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = StakingApiFp(configuration);
    return {
        /**
         *
         * @summary Get all delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Submit delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject4} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Query the current delegation between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Submit a redelegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject6} [delegation]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all unbonding delegations from a delegator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Submit an unbonding delegation
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {InlineObject5} [delegation]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Query all unbonding delegations between a delegator and a validator
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Query all validators that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Query a validator that a delegator is bonded to
         * @param {string} delegatorAddr Bech32 AccAddress of Delegator
         * @param {string} validatorAddr Bech32 ValAddress of Delegator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
            return localVarFp.stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the current staking parameter values
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingParametersGet(options) {
            return localVarFp.stakingParametersGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the current state of the staking pool
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingPoolGet(options) {
            return localVarFp.stakingPoolGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all redelegations (filter by query params)
         * @param {string} [delegator] Bech32 AccAddress of Delegator
         * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
         * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options) {
            return localVarFp.stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all validator candidates. By default it returns only the bonded validators.
         * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
         * @param {number} [page] The page number.
         * @param {number} [limit] The maximum number of items per page.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingValidatorsGet(status, page, limit, options) {
            return localVarFp.stakingValidatorsGet(status, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options) {
            return localVarFp.stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Query the information from a single validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrGet(validatorAddr, options) {
            return localVarFp.stakingValidatorsValidatorAddrGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all unbonding delegations from a validator
         * @param {string} validatorAddr Bech32 OperatorAddress of validator
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options) {
            return localVarFp.stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * StakingApi - object-oriented interface
 * @export
 * @class StakingApi
 * @extends {BaseAPI}
 */
export class StakingApi extends BaseAPI {
    /**
     *
     * @summary Get all delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrDelegationsGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Submit delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject4} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrDelegationsPost(delegatorAddr, delegation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Query the current delegation between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Submit a redelegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject6} [delegation]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrRedelegationsPost(delegatorAddr, delegation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all unbonding delegations from a delegator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Submit an unbonding delegation
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {InlineObject5} [delegation]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsPost(delegatorAddr, delegation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Query all unbonding delegations between a delegator and a validator
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrUnbondingDelegationsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Query all validators that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrValidatorsGet(delegatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Query a validator that a delegator is bonded to
     * @param {string} delegatorAddr Bech32 AccAddress of Delegator
     * @param {string} validatorAddr Bech32 ValAddress of Delegator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options) {
        return StakingApiFp(this.configuration).stakingDelegatorsDelegatorAddrValidatorsValidatorAddrGet(delegatorAddr, validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the current staking parameter values
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingParametersGet(options) {
        return StakingApiFp(this.configuration).stakingParametersGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the current state of the staking pool
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingPoolGet(options) {
        return StakingApiFp(this.configuration).stakingPoolGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all redelegations (filter by query params)
     * @param {string} [delegator] Bech32 AccAddress of Delegator
     * @param {string} [validatorFrom] Bech32 ValAddress of SrcValidator
     * @param {string} [validatorTo] Bech32 ValAddress of DstValidator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options) {
        return StakingApiFp(this.configuration).stakingRedelegationsGet(delegator, validatorFrom, validatorTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all validator candidates. By default it returns only the bonded validators.
     * @param {string} [status] The validator bond status. Must be either \&#39;bonded\&#39;, \&#39;unbonded\&#39;, or \&#39;unbonding\&#39;.
     * @param {number} [page] The page number.
     * @param {number} [limit] The maximum number of items per page.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingValidatorsGet(status, page, limit, options) {
        return StakingApiFp(this.configuration).stakingValidatorsGet(status, page, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options) {
        return StakingApiFp(this.configuration).stakingValidatorsValidatorAddrDelegationsGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Query the information from a single validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingValidatorsValidatorAddrGet(validatorAddr, options) {
        return StakingApiFp(this.configuration).stakingValidatorsValidatorAddrGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all unbonding delegations from a validator
     * @param {string} validatorAddr Bech32 OperatorAddress of validator
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StakingApi
     */
    stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options) {
        return StakingApiFp(this.configuration).stakingValidatorsValidatorAddrUnbondingDelegationsGet(validatorAddr, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TendermintRPCApi - axios parameter creator
 * @export
 */
export const TendermintRPCApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksHeightGet: async (height, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('blocksHeightGet', 'height', height);
            const localVarPath = `/blocks/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksLatestGet: async (options = {}) => {
            const localVarPath = `/blocks/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingGet: async (options = {}) => {
            const localVarPath = `/syncing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsHeightGet: async (height, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('validatorsetsHeightGet', 'height', height);
            const localVarPath = `/validatorsets/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsLatestGet: async (options = {}) => {
            const localVarPath = `/validatorsets/latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TendermintRPCApi - functional programming interface
 * @export
 */
export const TendermintRPCApiFp = function (configuration) {
    const localVarAxiosParamCreator = TendermintRPCApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blocksHeightGet(height, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blocksHeightGet(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blocksLatestGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blocksLatestGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncingGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncingGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsetsHeightGet(height, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsetsHeightGet(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsetsLatestGet(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsetsLatestGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TendermintRPCApi - factory interface
 * @export
 */
export const TendermintRPCApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TendermintRPCApiFp(configuration);
    return {
        /**
         *
         * @summary Get a block at a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksHeightGet(height, options) {
            return localVarFp.blocksHeightGet(height, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the latest block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blocksLatestGet(options) {
            return localVarFp.blocksLatestGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get if the node is currently syning with other nodes
         * @summary Syncing state of node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingGet(options) {
            return localVarFp.syncingGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a validator set a certain height
         * @param {number} height Block height
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsHeightGet(height, options) {
            return localVarFp.validatorsetsHeightGet(height, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the latest validator set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsetsLatestGet(options) {
            return localVarFp.validatorsetsLatestGet(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TendermintRPCApi - object-oriented interface
 * @export
 * @class TendermintRPCApi
 * @extends {BaseAPI}
 */
export class TendermintRPCApi extends BaseAPI {
    /**
     *
     * @summary Get a block at a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    blocksHeightGet(height, options) {
        return TendermintRPCApiFp(this.configuration).blocksHeightGet(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the latest block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    blocksLatestGet(options) {
        return TendermintRPCApiFp(this.configuration).blocksLatestGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get if the node is currently syning with other nodes
     * @summary Syncing state of node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    syncingGet(options) {
        return TendermintRPCApiFp(this.configuration).syncingGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a validator set a certain height
     * @param {number} height Block height
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    validatorsetsHeightGet(height, options) {
        return TendermintRPCApiFp(this.configuration).validatorsetsHeightGet(height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the latest validator set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TendermintRPCApi
     */
    validatorsetsLatestGet(options) {
        return TendermintRPCApiFp(this.configuration).validatorsetsLatestGet(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        txsDecodePost: async (tx, options = {}) => {
            // verify required parameter 'tx' is not null or undefined
            assertParamExists('txsDecodePost', 'tx', tx);
            const localVarPath = `/txs/decode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(tx, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        txsEncodePost: async (tx, options = {}) => {
            // verify required parameter 'tx' is not null or undefined
            assertParamExists('txsEncodePost', 'tx', tx);
            const localVarPath = `/txs/encode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(tx, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        txsGet: async (messageAction, messageSender, page, limit, txMinheight, txMaxheight, options = {}) => {
            const localVarPath = `/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (messageAction !== undefined) {
                localVarQueryParameter['message.action'] = messageAction;
            }
            if (messageSender !== undefined) {
                localVarQueryParameter['message.sender'] = messageSender;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (txMinheight !== undefined) {
                localVarQueryParameter['tx.minheight'] = txMinheight;
            }
            if (txMaxheight !== undefined) {
                localVarQueryParameter['tx.maxheight'] = txMaxheight;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        txsHashGet: async (hash, options = {}) => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('txsHashGet', 'hash', hash);
            const localVarPath = `/txs/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsPost: async (txBroadcast, options = {}) => {
            // verify required parameter 'txBroadcast' is not null or undefined
            assertParamExists('txsPost', 'txBroadcast', txBroadcast);
            const localVarPath = `/txs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(txBroadcast, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async txsDecodePost(tx, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txsDecodePost(tx, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async txsEncodePost(tx, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txsEncodePost(tx, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async txsHashGet(hash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txsHashGet(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async txsPost(txBroadcast, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.txsPost(txBroadcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TransactionsApiFp(configuration);
    return {
        /**
         * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
         * @summary Decode a transaction from the Amino wire format
         * @param {InlineObject2} tx
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        txsDecodePost(tx, options) {
            return localVarFp.txsDecodePost(tx, options).then((request) => request(axios, basePath));
        },
        /**
         * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
         * @summary Encode a transaction to the Amino wire format
         * @param {InlineObject1} tx
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        txsEncodePost(tx, options) {
            return localVarFp.txsEncodePost(tx, options).then((request) => request(axios, basePath));
        },
        /**
         * Search transactions by events.
         * @summary Search transactions
         * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
         * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
         * @param {number} [page] Page number
         * @param {number} [limit] Maximum number of items per page
         * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
         * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options) {
            return localVarFp.txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a transaction using its hash.
         * @summary Get a Tx by hash
         * @param {string} hash Tx hash
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        txsHashGet(hash, options) {
            return localVarFp.txsHashGet(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Broadcast a signed tx to a full node
         * @summary Broadcast a signed tx
         * @param {InlineObject} txBroadcast
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        txsPost(txBroadcast, options) {
            return localVarFp.txsPost(txBroadcast, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON
     * @summary Decode a transaction from the Amino wire format
     * @param {InlineObject2} tx
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    txsDecodePost(tx, options) {
        return TransactionsApiFp(this.configuration).txsDecodePost(tx, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes
     * @summary Encode a transaction to the Amino wire format
     * @param {InlineObject1} tx
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    txsEncodePost(tx, options) {
        return TransactionsApiFp(this.configuration).txsEncodePost(tx, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search transactions by events.
     * @summary Search transactions
     * @param {string} [messageAction] transaction events such as \&#39;message.action&#x3D;send\&#39; which results in the following endpoint: \&#39;GET /txs?message.action&#x3D;send\&#39;. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory
     * @param {string} [messageSender] transaction tags with sender: \&#39;GET /txs?message.action&#x3D;send&amp;message.sender&#x3D;cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv\&#39;
     * @param {number} [page] Page number
     * @param {number} [limit] Maximum number of items per page
     * @param {number} [txMinheight] transactions on blocks with height greater or equal this value
     * @param {number} [txMaxheight] transactions on blocks with height less than or equal this value
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options) {
        return TransactionsApiFp(this.configuration).txsGet(messageAction, messageSender, page, limit, txMinheight, txMaxheight, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a transaction using its hash.
     * @summary Get a Tx by hash
     * @param {string} hash Tx hash
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    txsHashGet(hash, options) {
        return TransactionsApiFp(this.configuration).txsHashGet(hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Broadcast a signed tx to a full node
     * @summary Broadcast a signed tx
     * @param {InlineObject} txBroadcast
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    txsPost(txBroadcast, options) {
        return TransactionsApiFp(this.configuration).txsPost(txBroadcast, options).then((request) => request(this.axios, this.basePath));
    }
}
